#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
The program takes (optionally segmented) CSV files as inputs, processes the segment information (the "&"s) if applicable, and outputs an (.ac, .aa) pair of Glozz files.

The output files contain:
    - the .ac file will contain the text attributes of the dialogue turns (without the '&', one turn on a line).
    - the .aa file will contain:
        - a pre-annotation in terms of:
            - dialogue information:
                - cut at dice rollings;
                - trades,
                - dice rollings,
                - resource gettings.
            - turn information:
                - borders (implicit)
                - Identifier
                - Timestamp
                - Emitter
                - Resources
                - Developments
            - segment (UDE) information:
                - borders (implicit)
                - Shallow dialogue act: Question | Request | Assertion
                - Task dialogue act: Offer | Counteroffer | Accept | Refusal | Strategic_comment | Other

Usage:
>>> ./csvtoglozz.py -f <CSV file name>

@note: The output file names are formed by appending the .ac and .aa extensions to the input CSV file basename.
Example: for an input filename like document1.soclog.seg.csv, the pair  (document1.ac, document1.aa) is generated.
@note: The program supports filenames with empty spaces in them.
'''
import csv, sys, codecs
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
import datetime, time
from prettifyxml import prettify
import copy

# TODO: replace with XML declaration
root = Element('annotations', {'version':'1.0', 'encoding':'UTF-8', 'standalone':'no'})
root.append(Comment('Generated by csvtoglozz.py'))

import argparse
parser = argparse.ArgumentParser(description = '')
parser.add_argument('-f', '--file', dest = 'file', nargs = '+', help = "specify input file")
args = parser.parse_args(sys.argv[1:])
filename = ' '.join(args.file)

print filename

def append_unit(root, unit_id, date, type, features, left, right):
    metadata = [ ('author'              , 'stac')
               , ('creation-date'       , date)
               , ('lastModifier'        , 'n/a' )
               , ('lastModificationDate', '0'   )
               ]
    elm_unit     = SubElement(root, 'unit', {'id':unit_id})
    elm_metadata = SubElement(elm_unit, 'metadata')
    for k,v in metadata:
        e = SubElement(elm_metadata, k)
        e.text = v
    elm_charact = SubElement(elm_unit, 'characterisation')
    elm_type    = SubElement(elm_charact, 'type')
    elm_type.text = type
    elm_features = SubElement(elm_charact, 'featureSet')
    for k,v in features:
        e = SubElement(elm_features, 'feature', {'name':k})
        e.text = v

    elm_pos   = SubElement(elm_unit, 'positioning')
    elm_start = SubElement(elm_pos, 'start')
    elm_end   = SubElement(elm_pos, 'end')
    SubElement(elm_start, 'singlePosition', {'index':str(left)})
    SubElement(elm_end  , 'singlePosition', {'index':str(right)})

incsvfile = codecs.open(filename, 'rt')
csvreader = csv.reader(incsvfile, delimiter='\t')
firstcsvrow = csvreader.next()
dialoguetext = ' ' # for the .ac file
i=0
nb_dialogues = 0
dialog_leftborders = []
dialog_rightborders = []
csvrows = []
r_old = 0
for csvrow in csvreader:
    csvrows.append(csvrow)
for r in range(0,len(csvrows)):
    i += 1
    if csvrows[r] != firstcsvrow:
        try:
            the_row = copy.copy(csvrows[r])
            if len(the_row) >= 6 and len(the_row) < 8:
                padding = [''] * (8 - len(the_row))
                the_row.extend(padding)
            [curr_turn_id, curr_turn_timestamp, curr_turn_emitter, curr_turn_res, curr_turn_builds, curr_turn_text, curr_turn_annot, curr_turn_comment] = the_row
        except ValueError:
            print >> sys.stderr, "Error on row %d: %s" % (i, the_row)
            raise
    if curr_turn_emitter != "Server":
        dialoguetext +=curr_turn_id+' : '+curr_turn_emitter+' : '
        seg_leftborders = [len(dialoguetext)-1]
        seg_rightborders = [] # For dealing with ampersands which stand for segments' right borders
        # .ac buffer
        dialoguetext +=curr_turn_text+' '
        #dialog_leftborders = [0]
        #dialog_rightborders = [len(dialoguetext)-1]
        nosegs = 1
        for d in dialoguetext:
            if d == '&':
                nosegs += 1
                seg_rightborders.append(dialoguetext.index(d))
                if len(seg_rightborders) >= 1:
                    seg_leftborders.append(seg_rightborders[-1])
                dialoguetext = dialoguetext[:dialoguetext.index(d)]+dialoguetext[dialoguetext.index(d)+1:]
        seg_rightborders.append(len(dialoguetext)-1)
        for t in curr_turn_text:
            if t == '&':
                curr_turn_text = curr_turn_text[:curr_turn_text.index(t)]+curr_turn_text[curr_turn_text.index(t)+1:]
        # .aa typographic annotations
        #
        typid   = 'stac_'+str(-i)
        typdate = str(-i)

        if dialoguetext.index(curr_turn_text) != 0:
            typstart = len(dialoguetext) - len(curr_turn_text) - len(curr_turn_id) - len(curr_turn_emitter) - 1 - 6
        else:
            typstart = 0
        typend = len(dialoguetext)-1

        append_unit(root,
                    unit_id  = typid,
                    date     = typdate,
                    type     = 'paragraph',
                    features = [],
                    left     = typstart,
                    right    = typend)

        # .aa actual pre-annotations (Turn ID, Timestamp, Emitter)
        # a "Dialogue" Unit should be added, that is, Turns between Server's contributions containing "rolled"
        unitid        = 'stac_'+str(int(time.mktime(datetime.datetime.now().timetuple())+i))
        creation_date =         str(int(time.mktime(datetime.datetime.now().timetuple())+i))

        # To parse and (re)present in a suitable manner !
        curr_parsed_turn_builds = ""
        if len(curr_turn_builds) > 0:
            for item in curr_turn_builds.split("];"):
                if ']' not in item:
                    item += ']'
                curr_parsed_turn_builds += item.split("=")[0]
                curr_parsed_turn_builds += "="
                curr_parsed_turn_builds += str(len(set(eval(item.split("=")[1].replace("; ", ",")))))
                curr_parsed_turn_builds += "; "
        curr_parsed_turn_builds = curr_parsed_turn_builds.strip("; ")

        features = [ ('Identifier', curr_turn_id)
                   , ('Timestamp' , curr_turn_timestamp)
                   , ('Emitter'   , curr_turn_emitter)
                   , ('Resources' , curr_turn_res.split("; unknown=")[0])
                   , ('Developments', curr_parsed_turn_builds)
                   , ('Comments', 'Please write in remarks...')
                   ]

        if dialoguetext.index(curr_turn_text) != 0:
            actualstpos = len(dialoguetext)-len(curr_turn_text)-len(curr_turn_id)-len(curr_turn_emitter)-1-6
        else:
            actualstpos = 0
        actualendpos = len(dialoguetext)-1

        append_unit(root,
                    unit_id  = unitid,
                    date     = creation_date,
                    type     = 'Turn',
                    features = features,
                    left     = actualstpos,
                    right    = actualendpos)

        # Segments information
#        print seg_leftborders
#        print seg_rightborders
#        print nosegs
#        print csvrows[r]
#        print "##"
        if len(seg_leftborders) == len(seg_rightborders):
            for k in range(0,len(seg_leftborders)):
                segment_id = 'stac_'+str(int(time.mktime(datetime.datetime.now().timetuple())+10000+k))
                screation_date =     str(int(time.mktime(datetime.datetime.now().timetuple())+10000*i+k))
                append_unit(root,
                            unit_id  = segment_id,
                            date     = screation_date,
                            type     = 'Segment',
                            features = [],
                            left     = seg_leftborders[k]+1,
                            right    = seg_rightborders[k])

    if curr_turn_emitter == "Server" and "rolled a" in curr_turn_text: # dialogue right boundary
    # hence, a dialogue is between the beginning and such a text (minus server's turns), or between such a text + 1 and another such text (minus server's turns).
        dice_rollings = []
        gets = []
        trades = ''
        #trades = []
        for rr in range(r+1,len(csvrows)):
            if csvrows[rr][2] == 'Server':
                if 'rolled a' in csvrows[rr][5]:
                    # append to Dice_rolling feature values
                    dice_rollings.append(csvrows[rr][5])
                if 'gets' in csvrows[rr][5]:
                    # append to Gets feature values
                    gets.append(csvrows[rr][5])
            else:
                break
        #print "r_old : " + str(r_old)
        for rrr in range(r, r_old-1, -1):
            if csvrows[rrr][2] == 'Server' and 'traded' in csvrows[rrr][5]:
                # append to Trades feature values
                trades = csvrows[rrr][5]
                break
#        print nb_dialogues
        #print dialog_leftborders
        #print dialog_rightborders
        r_old = r
        if nb_dialogues == 0:
            dialog_leftborders = [0]
            dialog_rightborders = [len(dialoguetext)-1]
        else:
            dialog_leftborders.append(dialog_rightborders[-1])
            dialog_rightborders.append(len(dialoguetext)-1)
        nb_dialogues += 1
        # Generate the actual annotation !
        if dialog_leftborders[-1] != dialog_rightborders[-1]:
            dialogue_id = 'stac_'+str(int(time.mktime(datetime.datetime.now().timetuple())+100000+nb_dialogues))
            dcreation_date=       str(int(time.mktime(datetime.datetime.now().timetuple())+100000*i+nb_dialogues))

            # extra rollings
            delfDiceroll = curr_turn_text
            if len(dice_rollings) >= 1:
                for roll in range(0,len(dice_rollings)):
                    delfDiceroll += ' '+dice_rollings[roll]
            # extra gets
            delfGets = ''
            if len(gets) >= 1:
                for get in range(0,len(gets)):
                    delfGets += ' '+gets[get]
            # extra trades
            delfTrades = trades
            #if len(trades) >= 1:
            #    for trade in range(0,len(trades)):
            #        delfTrades.text += ' '+trades[trade]

            dfeatures = [ ('Dice_rolling', delfDiceroll)
                        , ('Gets'        , delfGets)
                        , ('Trades'      , delfTrades)
                        ]

            append_unit(root,
                        unit_id  = dialogue_id,
                        date     = dcreation_date,
                        type     = 'Dialogue',
                        features = dfeatures,
                        left     = dialog_leftborders[-1],
                        right    = dialog_rightborders[-1])

# last dialogue : only if it doesn't end in a Server's statement !!

if len(dialog_rightborders) == 0 or dialog_rightborders[-1] != len(dialoguetext)-1:

    unit_id       = 'stac_'+str(int(time.mktime(datetime.datetime.now().timetuple())+100000+nb_dialogues+1))
    creation_date =         str(int(time.mktime(datetime.datetime.now().timetuple())+100000*i+nb_dialogues+1))
    unit_type = 'Dialogue'

    if len(dialog_leftborders) >= 1:
        span_left = str(dialog_leftborders[-1])
    else:
        span_left = str(0)
    span_right = str(len(dialoguetext))

    append_unit(root,
                unit_id    = unit_id,
                date       = creation_date,
                type       = 'Dialogue',
                features   = [],
                left       = span_left,
                right      = span_right)

#for b in range(0,len(dialog_leftborders)):
#    print ">>>>>>>>>>>"
#    print dialoguetext[dialog_leftborders[b]:dialog_rightborders[b]]
#    print "<<<<<<<<<<<"

basename=filename.split(".")[0]
outtxtfile = codecs.open(basename+".ac", "w")
outtxtfile.write(dialoguetext)
outtxtfile.close()
outxmlfile = codecs.open(basename+".aa", "w", "ascii")
outxmlfile.write(prettify(root))
outxmlfile.close()
