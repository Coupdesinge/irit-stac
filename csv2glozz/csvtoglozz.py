#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
Now, what we should do: take the .seg.csv files (that is, csv files with segmentation information), process the '&'s and output an .ac file with text only and an .aa file with Glozz pre-annotations corresponding to the 'Dialogue' objects. Thus,
-- the .ac file will contain the text attributes of the dialogue turns (without the '&', one turn on a line).
-- the .aa file will contain:
	-- a pre-annotation in terms of:
		-- turn information:
			-- borders (implicit)
			-- Identifier:<ID>
			-- Timestamp:<nn:nn:nnn>
			-- Emitter
			-- Resources:[res_1:<qty_1>, ..., res_n:<qty_n>]
			-- Buildups:[roads:[(x_1,y_1), ..., (x_m,y_m)]]
		-- segment (UDE) information:
			-- borders (implicit)
			-- Shallow dialogue act:Question | Request | Assertion
			-- Task dialogue act:Offer | Counteroffer | Has-resources | Acceptance | Refusal | Strategic-comment | Other
'''
import csv, sys, codecs
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
import datetime, time
from prettifyxml import prettify

root = Element('annotations', {'version':'1.0', 'encoding':'UTF-8', 'standalone':'no'})
root.append(Comment('Generated by csvtoglozz.py'))

incsvfile = codecs.open(sys.argv[1], 'rt')
csvreader = csv.reader(incsvfile, delimiter='\t')
firstcsvrow = csvreader.next()
dialoguetext = ' ' # for the .ac file
i=0

for csvrow in csvreader:
	i += 1
	if csvrow != firstcsvrow:
		[curr_turn_id, curr_turn_timestamp, curr_turn_emitter, curr_turn_res, curr_turn_builds, curr_turn_text, curr_turn_annot, curr_turn_comment] = csvrow
	if curr_turn_emitter != "Server":
		dialoguetext +=curr_turn_id+' : '+curr_turn_emitter+' : '
		seg_leftborders = [len(dialoguetext)-1]
		seg_rightborders = [] # For dealing with ampersands which stand for segments' right borders
		# .ac buffer
		dialoguetext +=curr_turn_text+' '
		nosegs = 1
		for d in dialoguetext:
			if d == '&':
				nosegs += 1
				seg_rightborders.append(dialoguetext.index(d))
				if len(seg_rightborders) >= 1:
					seg_leftborders.append(seg_rightborders[-1])
				dialoguetext = dialoguetext[:dialoguetext.index(d)]+dialoguetext[dialoguetext.index(d)+1:]
		seg_rightborders.append(len(dialoguetext)-1)
		for t in curr_turn_text:
			if t == '&':
				curr_turn_text = curr_turn_text[:curr_turn_text.index(t)]+curr_turn_text[curr_turn_text.index(t)+1:]
		# .aa typographic annotations
		typunit = SubElement(root, 'unit', {'id':'stac_'+str(-i)})
		typmetadata = SubElement(typunit, 'metadata')
		typauthor = SubElement(typmetadata, 'author')
		typauthor.text='stac'
		typcreation_date = SubElement(typmetadata, 'creation-date')
		typcreation_date.text = str(-i)
		typlast_modif = SubElement(typmetadata, 'lastModifier')
		typlast_modif.text = 'n/a'
		typlast_modif_date = SubElement(typmetadata, 'lastModificationDate')
		typlast_modif_date.text = '0'
		typcharact = SubElement(typunit, 'characterisation')
		typeltype = SubElement(typcharact, 'type')
		typeltype.text = 'paragraph'
		typelfset = SubElement(typcharact, 'featureSet')
		typpos = SubElement(typunit, 'positioning')
		typstartpos = SubElement(typpos, 'start')
		if dialoguetext.index(curr_turn_text) != 0:
			typactualstpos = SubElement(typstartpos, 'singlePosition', {'index':str(len(dialoguetext)-len(curr_turn_text)-len(curr_turn_id)-len(curr_turn_emitter)-1-6)})
		else:
			typactualstpos = SubElement(typstartpos, 'singlePosition', {'index':str(0)})
		typendpos = SubElement(typpos, 'end')
		typactualendpos = SubElement(typendpos, 'singlePosition', {'index':str(len(dialoguetext)-1)})
		# .aa actual pre-annotations (Turn ID, Timestamp, Emitter)
		unit = SubElement(root, 'unit', {'id':'stac_'+str(int(time.mktime(datetime.datetime.now().timetuple())+i))})
		metadata = SubElement(unit, 'metadata')
		author = SubElement(metadata, 'author')
		author.text='stac'
		creation_date = SubElement(metadata, 'creation-date')
		creation_date.text = str(int(time.mktime(datetime.datetime.now().timetuple())+i))
		last_modif = SubElement(metadata, 'lastModifier')
		last_modif.text = 'n/a'
		last_modif_date = SubElement(metadata, 'lastModificationDate')
		last_modif_date.text = '0'
		charact = SubElement(unit, 'characterisation')
		eltype = SubElement(charact, 'type')
		eltype.text = 'Turn'
		elfset = SubElement(charact, 'featureSet')
		elfID = SubElement(elfset, 'feature', {'name':'Identifier'})
		elfID.text = curr_turn_id
		elfTimestamp = SubElement(elfset, 'feature', {'name':'Timestamp'})
		elfTimestamp.text = curr_turn_timestamp
		elfEmitter = SubElement(elfset, 'feature', {'name':'Emitter'})
		elfEmitter.text = curr_turn_emitter
		elfResources = SubElement(elfset, 'feature', {'name':'Resources'})
		elfResources.text = curr_turn_res
		elfBuildups = SubElement(elfset, 'feature', {'name':'Buildups'})
		elfBuildups.text = curr_turn_builds
		elfComments = SubElement(elfset, 'feature', {'name':'Comments'})
		elfComments.text = 'Please write in remarks...'
		pos = SubElement(unit, 'positioning')
		startpos = SubElement(pos, 'start')
		if dialoguetext.index(curr_turn_text) != 0:
			actualstpos = SubElement(startpos, 'singlePosition', {'index':str(len(dialoguetext)-len(curr_turn_text)-len(curr_turn_id)-len(curr_turn_emitter)-1-6)})
		else:
			actualstpos = SubElement(startpos, 'singlePosition', {'index':str(0)})
		endpos = SubElement(pos, 'end')
		actualendpos = SubElement(endpos, 'singlePosition', {'index':str(len(dialoguetext)-1)})
		# Segments information
		print seg_leftborders
		print seg_rightborders
		print nosegs
		print csvrow
		print "##"
		if len(seg_leftborders) == len(seg_rightborders):
			for k in range(0,len(seg_leftborders)):
				segment = SubElement(root, 'unit', {'id':'stac_'+str(int(time.mktime(datetime.datetime.now().timetuple())+10000+k))})
				smetadata = SubElement(segment, 'metadata')
				sauthor = SubElement(smetadata, 'author')
				sauthor.text='stac'
				screation_date = SubElement(smetadata, 'creation-date')
				screation_date.text = str(int(time.mktime(datetime.datetime.now().timetuple())+10000*i+k))
				slast_modif = SubElement(smetadata, 'lastModifier')
				slast_modif.text = 'n/a'
				slast_modif_date = SubElement(smetadata, 'lastModificationDate')
				slast_modif_date.text = '0'
				scharact = SubElement(segment, 'characterisation')
				seltype = SubElement(scharact, 'type')
				seltype.text = 'Segment'
				selfset = SubElement(scharact, 'featureSet')
				spos = SubElement(segment, 'positioning')
				sstartpos = SubElement(spos, 'start')
				sactualstpos = SubElement(sstartpos, 'singlePosition', {'index':str(seg_leftborders[k]+1)})
				sendpos = SubElement(spos, 'end')
				sactualendpos = SubElement(sendpos, 'singlePosition', {'index':str(seg_rightborders[k])})
outtxtfile = codecs.open(sys.argv[1].split(".")[0]+".ac", "w")
outtxtfile.write(dialoguetext)
outtxtfile.close()
outxmlfile = codecs.open(sys.argv[1].split(".")[0]+".aa", "w", "ascii")
outxmlfile.write(prettify(root))
outxmlfile.close()
