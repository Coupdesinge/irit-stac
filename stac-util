#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Author: Eric Kow
# License: BSD3

"""
STAC Swiss-Army knife modeled on the Glozz equivalent
"""

import argparse
from   collections import defaultdict
import copy
import itertools
import math
import os
import re
import sys
import tempfile
import textwrap
from   cStringIO import StringIO

import educe.util
from educe import glozz, stac
from educe.annotation import Unit, Relation, Schema, Span
from educe.stac import stac_output_settings, stac_unannotated_output_settings

# ---------------------------------------------------------------------
# very generic utilities
# ---------------------------------------------------------------------

def concat(xs):
    """
    Flatten a list of lists into a list.
    """
    return list(itertools.chain.from_iterable(xs))

# ---------------------------------------------------------------------
# stac utilities
# ---------------------------------------------------------------------

def anno_id_from_tuple(t):
    return "%s_%d" % t

def anno_id_to_tuple(string):
    parts = string.split('_')
    if len(parts) != 2:
        msg = "%r is not of form author_date" % string
        raise Exception(msg)
    return (parts[0],int(parts[1]))

def get_output_dir(args):
    if args.output:
        if os.path.isfile(args.output):
            print >> sys.stderr, "Sorry, %s already exists and is not a directory" % args.output
            sys.exit(1)
        elif not os.path.isdir(args.output):
            os.makedirs(args.output)
        return args.output
    elif "overwrite_input" in args.__dict__ and args.overwrite_input:
        return args.corpus
    else:
        return tempfile.mkdtemp()

def output_path_stub(odir, k):
    # directory and basename, needs extension
    relpath        = stac.id_to_path(k)
    ofile_dirname  = os.path.join(odir, os.path.dirname(relpath))
    ofile_basename = os.path.basename(relpath)
    return os.path.join(ofile_dirname, ofile_basename)

def mk_parent_dirs(f):
    dirname = os.path.dirname(f)
    if not os.path.exists(dirname):
        os.makedirs(dirname)

def save_document(output_dir, k, doc):
    stub = output_path_stub(output_dir, k)
    mk_parent_dirs(stub)
    doc_bytes = doc.text().encode('utf-8')
    is_unannotated = k.stage == 'unannotated'

    # .aa file
    settings = stac_unannotated_output_settings\
            if is_unannotated else stac_output_settings
    out_doc          = copy.copy(doc)
    out_doc.hashcode = glozz.hashcode(StringIO(doc_bytes))
    glozz.write_annotation_file(stub + ".aa", out_doc, settings=settings)

    # .ac file
    if is_unannotated:
        with open(stub + ".ac", 'wb') as f:
            f.write(doc_bytes)

def anno_author(x):
    return x.metadata['author']

def anno_date(x):
    return int(x.metadata['creation-date'])

def get_turn(tid, doc):
    """
    Return the turn annotation with the desired ID
    """
    def is_match(x):
        return stac.is_turn(x) and int(x.features['Identifier']) == tid
    turns = filter(is_match, doc.annotations())
    if not turns:
        sys.exit("Turn %d not found" % tid)
    elif len(turns) > 1:
        sys.exit("Huh?! Found more than one turn with id %d" % tid)
    else:
        return turns[0]


# ---------------------------------------------------------------------
# annotate
# ---------------------------------------------------------------------

default_inserts =\
        { 'Turn'   : ('\n', '')
        , 'Dialogue' : ('\n', '')
        , 'Segment': ('[', ']')
        }

def rough_type(anno):
    """
    Simplify STAC annotation types
    """
    if anno.type == 'Segment' or stac.is_edu(anno):
        return 'Segment'
    else:
        return anno.type

def sorted_first_widest(xs):
    """
    Given a list of nodes, return the nodes ordered by their starting point,
    and in case of a tie their inverse width (ie. widest first).
    """
    def from_span(sp):
        # negate the endpoint so that if we have a tie on the starting
        # point, the widest span comes first
        if sp:
            return (sp.char_start, 0 - sp.char_end)
        else:
            return None
    return sorted(xs, key=lambda x:from_span(x.text_span()))

def annotate(txt, annotations, inserts=default_inserts):
    """
    Decorate a text with arbitrary bracket symbols, as a visual
    guide to the annotations on that text. For example, in a
    chat corpus, you might use newlines to indicate turn
    boundaries and square brackets for segments.

    FIXME: this needs to become a standard educe utility,
    maybe as part of the educe.annotation layer?
    """
    def is_visible(x):
        return rough_type(x) in inserts
    if not annotations:
        return txt

    def add_endpoints(endpoints, buf, i):
        endpoints2 = []
        buf2 = buf
        for i2,rparen in endpoints:
            if i == i2:
                buf2 = buf2 + rparen
            else:
                endpoints2.append((i2,rparen))
        return endpoints2, buf2

    s_annos    = sorted_first_widest(filter(is_visible, annotations))
    endpoints  = []
    buf        = ""
    for i in range(0,len(txt)):
        c = txt[i]
        endpoints, buf = add_endpoints(endpoints, buf, i)
        while s_annos:
            nxt = s_annos[0]
            sp  = nxt.text_span()
            if sp.char_start == i:
                lparen, rparen = inserts[rough_type(nxt)]
                buf = buf + lparen
                endpoints.insert(0,(sp.char_end,rparen)) # lifo
                del s_annos[0]
            else:
                break
        buf = buf + c

    _, buf = add_endpoints(endpoints, buf, len(txt))
    return buf

# ---------------------------------------------------------------------
# portion adjustment
# ---------------------------------------------------------------------

def is_portion(anno):
    return anno.type == 'portion'

def is_portion_adjustment(anno):
    return anno.type in [ 'portion', 'merge' ]

def appends_to_last(portion):
    return portion.text_span.char_start == 0

def evil_set_text(doc, text):
    """
    This is a bit evil as it's using undocumented functionality
    from the educe.annotation.Document object
    """
    doc._text = text

def evil_set_id(anno, author, date):
    """
    This is a bit evil as it's using undocumented functionality
    from the educe.annotation.Standoff object
    """
    anno._anno_id = anno_id_from_tuple((author, date))
    anno.metadata['author']        = author
    anno.metadata['creation-date'] = str(date)

def shift_annotations(doc, offset):
    """
    Return a deep copy of a document such that all annotations
    have been shifted by an offset.

    If shifting right, we pad the document with whitespace
    to act as filler. If shifting left, we cut the text
    """
    def shift(x):
        if offset != 0 and isinstance(x, Unit):
            x2      = copy.deepcopy(x)
            x2.span = x.span.shift(offset)
            return x2
        else:
            return copy.deepcopy(x)

    if offset > 0:
        padding = " " * offset
        txt2    = padding + doc.text()
    else:
        start   = 0-offset
        txt2    = doc.text()[start:]
    doc2           = copy.copy(doc)
    evil_set_text(doc2, txt2)
    doc2.units     = map(shift, doc.units)
    doc2.schemas   = map(shift, doc.schemas)
    doc2.relations = map(shift, doc.relations)
    return doc2

def narrow_to_span(doc, span):
    """
    Return a deep copy of a document with only the text and
    annotations that are within the span specified by portion.
    """
    offset = 0 - span.char_start
    def slice(xs):
        return [ copy.copy(x) for x in xs if span.encloses(x.text_span()) ]
    doc2           = copy.copy(doc)
    doc2.units     = slice(doc.units)
    doc2.schemas   = slice(doc.schemas)
    doc2.relations = slice(doc.relations)
    doc2           = shift_annotations(doc2, offset)
    evil_set_text(doc2, doc.text()[span.char_start:span.char_end])
    return doc2

def compute_renames(avoid, incoming):
    """
    Given two sets of documents, return a dictionary which would
    allow us to rename ids in `incoming` so that they do not
    overlap with those in `avoid`.

    :rtype `author -> date -> date`
    """
    dates   = defaultdict(list)
    renames = defaultdict(dict)
    for doc1 in avoid.values():
        for a in doc1.annotations():
            author  = anno_author(a)
            date    = anno_date(a)
            dates[author].append(date)
    min_dates = { k:min(v) for k,v in dates.items() }
    max_dates = { k:max(v) for k,v in dates.items() }
    for doc2 in incoming.values():
        for a in doc2.annotations():
            author   = anno_author(a)
            old_date = anno_date(a)
            if author in dates and old_date in dates[author] and\
               not (author in renames and old_date in renames[author]):
                if old_date < 0:
                    new_date = min_dates[author] - 1
                    min_dates[author] = new_date
                else:
                    new_date = max_dates[author] + 1
                    max_dates[author] = new_date
                dates[author].append(new_date)
                renames[author][old_date] = new_date
    return renames

def rename_ids(renames, doc):
    """
    Return a deep copy of a document, with ids reassigned
    according to the renames dictionary
    """
    doc2 = copy.deepcopy(doc)
    for a in doc2.annotations():
        author  = anno_author(a)
        date    = anno_date(a)
        if author in renames and date in renames[author]:
            new_date = renames[author][date]
            set_anno_date(a, new_date)
            evil_set_id(a, author, new_date)
    return doc2

def move_portion(renames, src_doc, tgt_doc, src_span, prepend=False):
    """
    Return a copy of the documents such that the src_span has been moved
    from source to target
    """
    snipped    = narrow_to_span(src_doc, src_span)
    src_txt    = snipped.text()
    tgt_txt    = tgt_doc.text()
    if prepend and tgt_txt[0] == ' ':
        old_len    = len(tgt_txt)
        tgt_txt    = tgt_txt.lstrip()
        pad_len    = old_len - len(tgt_txt)
        src_offset = 0
        tgt_offset = len(src_txt) - pad_len
    elif not prepend and src_txt[0]  == ' ':
        tgt_txt    = tgt_txt.rstrip()
        src_offset = len(tgt_txt)
        tgt_offset = 0

    snipped    = shift_annotations(snipped, src_offset)
    snipped    = rename_ids(renames, snipped)

    new_tgt_doc           = shift_annotations(tgt_doc, tgt_offset)
    new_tgt_doc.units     = new_tgt_doc.units     + snipped.units
    new_tgt_doc.relations = new_tgt_doc.relations + snipped.relations
    new_tgt_doc.schemas   = new_tgt_doc.schemas   + snipped.schemas

    if prepend:
        if src_span != snipped.text_span():
            print src_span
            print snipped.text_span()
            raise Exception('Not yet implemented: prepending from other than whole doc: %s' % src_span)
        # tgt_doc is on the right
        evil_set_text(new_tgt_doc, src_txt + tgt_txt)
        return None, new_tgt_doc
    else:
        if src_span.char_start != 0:
            raise Exception('Not yet implemented: moving from other than document start: %s' % src_span)
        # tgt_doc is on the left
        evil_set_text(new_tgt_doc, tgt_txt + src_txt)
        leftover_src_span = Span(src_span.char_end,len(src_doc.text()))
        new_src_doc       = narrow_to_span(src_doc, leftover_src_span)
        return new_src_doc, new_tgt_doc

# ---------------------------------------------------------------------
# COMMAND move
# ---------------------------------------------------------------------

def is_target(args):
    def is_match(k):
        return k.doc == args.doc and k.subdoc == args.target
    return is_match

def is_requested(args):
    def is_match(k):
        return k.doc == args.doc and k.subdoc == args.subdoc
    return is_match

def reflow(text, width=40):
    def wrap(t):
        xs = textwrap.wrap(t, width)
        if xs:
            return xs
        else:
            return ['']
    return concat(wrap(t) for t in text.split("\n"))

def annotate_doc(doc):
    return annotate(doc.text(), doc.annotations())

def show_diff(doc_before, doc_after):
    lines_before = reflow(annotate_doc(doc_before))
    lines_after  = reflow(annotate_doc(doc_after))
    pairs = itertools.izip_longest(lines_before, lines_after, fillvalue='')
    return "\n".join("%-40s | %-40s" % p for p in pairs)

def main_move(args):
    output_dir = get_output_dir(args)
    if args.start != 0:
        print >> sys.stderr, "Sorry, only know how to deal with start=0 at the moment"
        sys.exit(1)

    reader     = stac.Reader(args.corpus)
    src_files  = reader.filter(reader.files(), is_requested(args))
    tgt_files  = reader.filter(reader.files(), is_target(args))
    src_corpus = reader.slurp(src_files)
    tgt_corpus = reader.slurp(tgt_files)

    portion    = Span(args.start, args.end)

    renames = compute_renames(tgt_corpus, src_corpus)
    for src_k in src_corpus:
        tgt_k        = copy.copy(src_k)
        tgt_k.subdoc = args.target
        if tgt_k not in tgt_corpus:
            print >> sys.stderr, "Uh-oh! we don't have %s in the corpus" % tgt_k
            sys.exit(1)
        else:
            src_doc = src_corpus[src_k]
            tgt_doc = tgt_corpus[tgt_k]
            new_src_doc, new_tgt_doc = move_portion(renames, src_doc, tgt_doc, portion)
            diffs = ["======= TO %s   ========" % tgt_k,
                     show_diff(tgt_doc, new_tgt_doc),
                     "^------ FROM %s" % src_k,
                     show_diff(src_doc, new_src_doc),
                     ""]
            print >> sys.stderr, "\n".join(diffs)
            save_document(output_dir, src_k, new_src_doc)
            save_document(output_dir, tgt_k, new_tgt_doc)

    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# COMMAND insert
# ---------------------------------------------------------------------

def main_insert(args):
    output_dir = get_output_dir(args)

    src_reader = stac.LiveInputReader(args.insert)
    src_corpus = src_reader.slurp(src_reader.files())

    if not src_corpus:
        print >> sys.stderr, "Insert dir must have exactly one .aa/.ac pair (none found)"
        sys.exit(1)
    elif len(src_corpus) > 1:
        print >> sys.stderr, "Insert dir must have exactly one .aa/.ac pair (%d found)" % len(src_corpus)
        sys.exit(1)

    src_doc    = src_corpus.values()[0]
    src_span   = src_doc.text_span()

    reader     = stac.Reader(args.corpus)
    tgt_files  = reader.filter(reader.files(), is_requested(args))
    tgt_corpus = reader.slurp(tgt_files)

    renames = compute_renames(tgt_corpus, src_corpus)
    for tgt_k in tgt_corpus:
        tgt_doc = tgt_corpus[tgt_k]
        _, new_tgt_doc = move_portion(renames, src_doc, tgt_doc, src_span, prepend=True)
        diffs = ["======= INSERT IN %s   ========" % tgt_k,
                 show_diff(tgt_doc, new_tgt_doc)]
        print >> sys.stderr, "\n".join(diffs).encode('utf-8')
        save_document(output_dir, tgt_k, new_tgt_doc)

    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# COMMAND text
# ---------------------------------------------------------------------

def main_text(args):
    is_interesting = educe.util.mk_is_interesting(args)
    reader     = stac.Reader(args.corpus)
    anno_files = reader.filter(reader.files(), is_interesting)
    corpus     = reader.slurp(anno_files, verbose=True)
    for k in sorted(corpus, key=stac.id_to_path):
        doc = corpus[k]
        def anno(sp=None):
            if sp:
                units_ = [u for u in doc.units if sp.encloses(u.span)]
                units  = copy.deepcopy(units_)
                for x in units:
                    x.span = x.span.relative(sp)
            else:
                units = doc.units
            return annotate(doc.text(sp), units).strip()
        print "========== %s ============" % k
        print
        if args.edges:
            dialogues = sorted_first_widest(u for u in doc.units if u.type == 'Dialogue')
            if dialogues:
                d_first = dialogues[0]
                print anno(d_first.text_span())
                if len(dialogues) > 1:
                    d_last = dialogues[-1]
                    print "...\n"
                    print anno(d_last.text_span()).encode('utf-8')
        else:
            print anno().encode('utf-8')
        print

# ---------------------------------------------------------------------
# COMMAND filter
# ---------------------------------------------------------------------

def main_filter(args):
    is_interesting = educe.util.mk_is_interesting(args)
    output_dir     = get_output_dir(args)
    reader         = stac.Reader(args.corpus)
    anno_files     = reader.filter(reader.files(), is_interesting)
    corpus         = reader.slurp(anno_files, verbose=True)
    preds          = []
    if args.type:
        r = re.compile(args.type)
        def fn(x):
            m = r.search(x.type)
            return m is not None and m.span() != (0,0)
        preds.append(fn)
    if args.not_id:
        def fn(x):
            return x.local_id() != args.not_id
        preds.append(fn)
    if preds:
        pred = lambda x:all([f(x) for f in preds])
    else:
        print >> sys.stderr, "No filters specified, aborting"
        sys.exit(1)

    for k in corpus:
        doc = corpus[k]
        doc.units     = filter(pred, doc.units)
        doc.relations = filter(pred, doc.relations)
        doc.schemas   = filter(pred, doc.schemas)
        save_document(output_dir, k, doc)
    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# COMMAND rename
# ---------------------------------------------------------------------

def main_rename(args):
    if args.stage != 'unannotated' and not args.annotator:
        sys.exit("--annotator is required unless --stage is unannotated")
    elif args.stage == 'unannotated' and args.annotator:
        sys.exit("--annotator is forbidden if --stage is unannotated")
    def is_match(anno_tuple):
        match_id = anno_id_from_tuple(anno_tuple)
        def pred(x):
            return x.local_id() == match_id
        return pred

    is_interesting = educe.util.mk_is_interesting(args)
    output_dir     = get_output_dir(args)
    reader         = stac.Reader(args.corpus)
    anno_files     = reader.filter(reader.files(), is_interesting)
    corpus         = reader.slurp(anno_files, verbose=True)

    source_author, source_date = args.source
    pretty_source = anno_id_from_tuple(args.source)
    if args.target:
        # check for collisions
        target_author, target_date = args.target
        pretty_target = anno_id_from_tuple(args.target)
        for k in corpus:
            doc = corpus[k]
            if filter(is_match(args.target), doc.annotations()):
                sys.exit("Can't rename! We already have annotation(s) with ID %s" % pretty_target)
    else:
        # generate a new name
        renames = compute_renames(corpus, corpus)
        target_author = source_author
        target_date   = renames[source_author][source_date]
        pretty_target = anno_id_from_tuple((target_author, target_date))

    def replace_pointer(ms):
        return [ pretty_target if m == pretty_source else m for m in ms ]

    for k in corpus:
        print k
        doc     = corpus[k]
        matches = filter(is_match(args.source), doc.annotations())
        if not matches:
            sys.exit("No annotations found with id %s" % pretty_source)
        elif len(matches) > 1:
            sys.exit("Huh?! More than one annotation with id %s" % pretty_source)
        match = matches[0]
        evil_set_id(matches[0], target_author, target_date)
        for x in doc.relations:
            if x.span.t1 == pretty_source:
                x.span.t1 = pretty_target
            if x.span.t2 == pretty_source:
                x.span.t2 = pretty_target
        for x in doc.schemas:
            x.units     = replace_pointer(x.units)
            x.relations = replace_pointer(x.relations)
            x.schemas   = replace_pointer(x.schemas)
        save_document(output_dir, k, doc)

    print >> sys.stderr, "Renamed from %s to %s" % (pretty_source, pretty_target)
    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# COMMAND rewrite
# ---------------------------------------------------------------------

def sans_modified_by(anno):
    anno2 = copy.deepcopy(anno)
    anno2.metadata['lastModifier']         = 'n/a'
    anno2.metadata['lastModificationDate'] = 0
    return anno2

def diff_friendly(annos):
    return sorted_first_widest(map(sans_modified_by, annos))

def main_rewrite(args):
    is_interesting = educe.util.mk_is_interesting(args)
    output_dir     = get_output_dir(args)
    reader         = stac.Reader(args.corpus)
    anno_files     = reader.filter(reader.files(), is_interesting)
    corpus         = reader.slurp(anno_files, verbose=True)
    for k in corpus:
        doc = corpus[k]
        if args.diff_friendly:
            doc.units     = diff_friendly(doc.units)
            doc.relations = diff_friendly(doc.relations)
            doc.schemas   = diff_friendly(doc.schemas)
        save_document(output_dir, k, doc)
    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# COMMAND nudge
# ---------------------------------------------------------------------

def enclosing_turn_span(doc, span):
    """
    Return the span for any turn annotations that enclose this span.
    If none are found, return the span itself
    """
    def is_match(x):
        return stac.is_turn(x) and x.text_span().encloses(span)
    spans = [span] + [ u.text_span() for u in doc.units if is_match(u) ]
    return Span(min(x.char_start for x in spans),
                max(x.char_end   for x in spans))

def is_nudge(x):
    return abs(x) <= 1

def main_nudge(args):
    # FIXME: there's probably a more idiomatic way to express this
    # particularly as part of the argparse block
    if not args.allow_shove and\
            (not is_nudge(args.nudge_start) or
             not is_nudge(args.nudge_end)):
        msg = "Use --allow-shove if you really mean to nudge by [%d,%d]"\
                % (args.nudge_start, args.nudge_end)
        print >> sys.stderr, msg
        sys.exit(1)
    if not args.allow_shove and (args.annotator or args.stage):
        sys.exit("Use --allow-shove if you really mean to limit --stage or --annotator")
    if args.stage:
        if args.stage != 'unannotated' and not args.annotator:
            sys.exit("--annotator is required unless --stage is unannotated")
        elif args.stage == 'unannotated' and args.annotator:
            sys.exit("--annotator is forbidden if --stage is unannotated")
    is_interesting = educe.util.mk_is_interesting(args)
    output_dir     = get_output_dir(args)
    reader         = stac.Reader(args.corpus)
    anno_files     = reader.filter(reader.files(), is_interesting)
    corpus         = reader.slurp(anno_files, verbose=True)
    old_span       = Span(args.start, args.end)
    new_span       = Span(args.start + args.nudge_start,
                          args.end   + args.nudge_end)
    for k in corpus:
        old_doc = corpus[k]
        new_doc = copy.deepcopy(old_doc)
        found   = False
        for a in new_doc.units:
            if a.span == old_span:
                a.span = copy.deepcopy(new_span)
                found  = True
        if found:
            interesting_span = enclosing_turn_span(old_doc, old_span)
            mini_old_doc = narrow_to_span(old_doc, interesting_span)
            mini_new_doc = narrow_to_span(new_doc, interesting_span)
            diffs = ["======= NUDGE %s to %s in %s ========" % (old_span, new_span, k),
                     "...",
                     show_diff(mini_old_doc, mini_new_doc),
                     "...",
                     ""]
            print >> sys.stderr, "\n".join(diffs).encode('utf-8')
        else:
            print >> sys.stderr, "WARNING: No annotations found for %s in %s" % (old_span, k)
        save_document(output_dir, k, new_doc)
    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# COMMAND merge dialogue
# ---------------------------------------------------------------------

def get_annotation_with_id(sought_tuple, annotations):
    sought = anno_id_from_tuple(sought_tuple)
    candidates = [ x for x in annotations if x.local_id() == sought ]
    if len(candidates) == 1:
        return candidates[0]
    elif len(candidates) > 1:
        raise Exception('More than one annotation found with id %s' % sought)
    else:
        raise Exception('No annotations found with id %s' % sought)

def concatenate_features(annotations, f):
    """
    Concatenate the values for the given features for all the annotations.
    Ignore cases where the feature is unset
    """
    values = filter(lambda x:x, [ x.features.get(f) for x in annotations ])
    if values:
        return " ".join(values)
    else:
        return None

def main_merge_dia(args):
    if not args.turns and len(args.dialogues) < 2:
        sys.exit("Must specify at least two dialogues")
    output_dir     = get_output_dir(args)
    is_interesting = educe.util.mk_is_interesting(args)
    reader         = stac.Reader(args.corpus)
    anno_files     = reader.filter(reader.files(), is_interesting)
    corpus         = reader.slurp(anno_files, verbose=True)
    if args.turns:
        if not corpus.values():
            sys.exit("No documents selected")
        doc  = corpus.values()[0]

        starting_turn = get_turn(args.turns[0], doc)
        ending_turn   = get_turn(args.turns[1], doc)
        span = Span(starting_turn.text_span().char_start - 1,
                    ending_turn.text_span().char_end + 1)
        def is_in_range(x):
            return x.type == 'Dialogue' and span.encloses(x.span)
        matching_dialogues = filter(is_in_range, doc.annotations())
        sought    = [ anno_id_to_tuple(x.local_id()) for x in matching_dialogues ]
        if len(sought) < 2:
            sys.exit("Must specify at least two dialogues")
        print >> sys.stderr, "Merging dialogues %s" % map(anno_id_from_tuple, sought)
    else:
        sought = args.dialogues
    for k in corpus:
        doc        = corpus[k]
        dialogues  = sorted([get_annotation_with_id(d, doc.units) for d in sought],
                            key=lambda x:x.text_span().char_start)
        combined      = copy.deepcopy(dialogues[0])
        combined.span =\
                Span(min(x.text_span().char_start for x in dialogues),
                     max(x.text_span().char_end   for x in dialogues))
        for f in [ 'Trades', 'Gets', 'Dice_rolling' ]:
            combined.features[f] = concatenate_features(dialogues, f)
        for d in dialogues:
            doc.units.remove(d)
        doc.units.append(combined)
        save_document(output_dir, k, doc)
    print >> sys.stderr, "Output files written to", output_dir

# ---------------------------------------------------------------------
# options
# ---------------------------------------------------------------------

def add_usual_input_args(p,
                         doc_subdoc_required=False,
                         help_suffix=None):
    p.add_argument('corpus', metavar='DIR', help='corpus dir')
    if doc_subdoc_required:
        doc_help    = 'document'
        subdoc_help = 'subdocument'
        if help_suffix:
            doc_help    = doc_help    + ' ' + help_suffix
            subdoc_help = subdoc_help + ' ' + help_suffix
        p.add_argument('--doc', metavar='DOC',
                       help=doc_help, required=doc_subdoc_required)
        p.add_argument('--subdoc', metavar='SUBDOC',
                       help=subdoc_help, required=doc_subdoc_required)
    else:
        educe.util.add_corpus_filters(p)


def add_usual_output_args(p):
    p.add_argument('--output', '-o', metavar='DIR',
                   help='output directory (default mktemp)')
    p.add_argument('--overwrite-input', action='store_true',
                   help='save results back to input dir')

def anno_id(string):
    parts = string.split('_')
    if len(parts) != 2:
        msg = "%r is not of form author_date" % string
        raise argparse.ArgumentTypeError(msg)
    return (parts[0],int(parts[1]))

arg_parser = argparse.ArgumentParser(description='STAC Swiss Army Knife')
subparsers = arg_parser.add_subparsers(help='sub-command help')

ap_text = subparsers.add_parser('text', help='dump the text in documents with segment annotations')
add_usual_input_args(ap_text)
ap_text.add_argument('--edges', action='store_true', help='First/last dialogues only')
ap_text.set_defaults(func=main_text)

ap_filter = subparsers.add_parser('filter', help='return a subset of the annotations')
add_usual_input_args(ap_filter)
add_usual_output_args(ap_filter)
ap_filter.add_argument('--type',   metavar='PY_REGEX', help='desired type (hint: negation via ^(?!foo)')
ap_filter.add_argument('--not-id', metavar='STRING',   help='id to delete')
ap_filter.set_defaults(func=main_filter)

ap_rewrite = subparsers.add_parser('rewrite', help='read and write back without changing anything else; potentially reformats XML (for version control diffs)')
ap_rewrite_mutex = ap_rewrite.add_mutually_exclusive_group()
add_usual_input_args(ap_rewrite)
add_usual_output_args(ap_rewrite_mutex)
ap_rewrite_mutex.add_argument('--diff-friendly',   action='store_true', help='Normalise for diffing')
ap_rewrite.set_defaults(func=main_rewrite)

ap_rename = subparsers.add_parser('rename', help='rename an annotation')
add_usual_input_args(ap_rename, doc_subdoc_required=True)
add_usual_output_args(ap_rename)
ap_rename.add_argument('--stage',     metavar='STAGE',  choices=['discourse', 'units', 'unannotated'], required=True)
ap_rename.add_argument('--annotator', metavar='STRING')
ap_rename.add_argument('--source', type=anno_id, metavar='ANNO_ID', required=True, help='id to rename (eg. kowey_398190)')
ap_rename.add_argument('--target', type=anno_id, metavar='ANNO_ID', help='id to rename to (default: autogenerated)')
ap_rename.set_defaults(func=main_rename)

ap_nudge = subparsers.add_parser('nudge', help='slightly adjust unit annotation boundaries')
add_usual_input_args(ap_nudge, doc_subdoc_required=True)
add_usual_output_args(ap_nudge)
ap_nudge.add_argument('start',  metavar='INT', type=int, help='text span start')
ap_nudge.add_argument('end',    metavar='INT', type=int, help='text span end')
ap_nudge.add_argument('nudge_start',  metavar='INT', type=int, help='adjust start [-1 to 1]')
ap_nudge.add_argument('nudge_end',    metavar='INT', type=int, help='adjust end   [-1 to 1]')
ap_nudge.add_argument('--allow-shove', action='store_true', help='allow adjustments larger than 1')
ap_nudge.add_argument('--stage',     metavar='STAGE',  choices=['discourse', 'units', 'unannotated'])
ap_nudge.add_argument('--annotator', metavar='STRING')
ap_nudge.set_defaults(func=main_nudge)

ap_insert = subparsers.add_parser('insert', help='insert new text into a portion')
add_usual_input_args(ap_insert, doc_subdoc_required=True, help_suffix='to insert into')
add_usual_output_args(ap_insert)
ap_insert.add_argument('insert', metavar='DIR', help='dir with just one pair of .aa/.ac files')
ap_insert.add_argument('start',  metavar='INT', type=int, help='insert before Nth char')
ap_insert.set_defaults(func=main_insert)

ap_move = subparsers.add_parser('move', help='Move text from one portion to another')
add_usual_input_args(ap_move, doc_subdoc_required=True, help_suffix='to move from')
add_usual_output_args(ap_move)
ap_move.add_argument('start',  metavar='INT', type=int, help='Text span start')
ap_move.add_argument('end',    metavar='INT', type=int, help='Text span end')
ap_move.add_argument('target', metavar='SUBDOC')
ap_move.set_defaults(func=main_move)

ap_merge_dia = subparsers.add_parser('merge-dialogue', help='Merge several dialogue level annotations into one')
add_usual_input_args(ap_merge_dia, doc_subdoc_required=True, help_suffix='in which to merge')
add_usual_output_args(ap_merge_dia)
ap_merge_dia_mutex = ap_merge_dia.add_mutually_exclusive_group(required=True)
ap_merge_dia_mutex.add_argument('--dialogues',
                                metavar='ANNO_ID', type=anno_id,
                                nargs='+',
                                help='eg. stac_39819045 stac_98871771')
ap_merge_dia_mutex.add_argument('--turns',
                                metavar='INT', type=int,
                                nargs=2,
                                help='eg. 187 192')
ap_merge_dia.set_defaults(func=main_merge_dia)

arg_parser.add_argument('--verbose', '-v',
                        action='count',
                        default=0)
args=arg_parser.parse_args()
args.func(args)
