#!/usr/bin/env python

# Simplify annotation filenames, by stripping away redundant
# information that is encoded in the filenames themselves.
#
# The goal (as proposed by Phillipe Mueller) is to bring
# some stability to the filenames, that the same file
# having been through different stages of processing or having
# been treated by different people should keep its identity.
# This allows people to know they are looking at the same
# file and also simplifies some tool usage, for example,
# going a graphical diff across directories.
#
# This is really meant as a one-shot tool, and is really here
# for archeological purposes only.
#
# Usage
#
# cd $DIR_TO_CLEAN
# PATH_TO_STAC/code/cleanup-2013-02/rename-files

import os
import re
import sys

if len(sys.argv) == 1:
    dir='.'
elif len(sys.argv) == 2:
    dir=sys.argv[1]
else:
    sys.stderr.write("Usage: %s [dir]" % sys.argv[0])
    sys.exit(1)

def clean_name(root, f):
    (bname,ext)=os.path.splitext(f)
    pad_pnum   = re.compile('(pilot\d\d_)(\d)(_|$)')
    strip_junk = re.compile('(pilot\d\d_\d*)_.*')
    nice_bname = strip_junk.sub('\g<1>', pad_pnum.sub('\g<1>0\g<2>\g<3>', bname))
    return os.path.join(root, nice_bname + ext)

for root, _, files in os.walk(dir):
    aa_files = [f for f in files if os.path.splitext(f)[1] == '.aa'] 
    for f in aa_files:
        old_name = os.path.join(root, f)
        new_name = clean_name(root, f)
        # we shell out because we want to invoke arbitrary commands
        # here using our version control system's move
        print ("git mv %s %s" % (old_name, new_name))
# vim: syntax=python:
