#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Author: Eric Kow
# License: BSD3

"""
Help visualise output of a discourse parser.  Concretely, augment unannotated
Glozz files with attachments/relations from some CSV file, producing a copy of
each aa file in an output directory.

As a minimum, each row of a CSV file has as a minimum the identifiers for the
document/subdocument, for two EDUs, and a relation label.  EDUs which do not
have attachments should be omitted from this file.  The name of the header must
be as in the csv header section of this script.

Quick start
-----------

    cd Stac
    python code/parser/parse-to-glozz\
           flat-dir-with-glozz-files\
           graph.conll\
           output-dir
    glozz-graph --live --png output-dir output-dir-png
"""

# pylint: disable=invalid-name
# pylint: enable=invalid-name

import argparse
import shutil
import os

from educe.annotation import RelSpan, Relation
import educe.corpus
import educe.glozz
import educe.stac
import educe.stac.util.glozz as stac_glozz
from educe.stac.util.context import Context
import educe.util

import stac.conll as pout

# ----------------------------------------------------------------------
# helpers
# ----------------------------------------------------------------------


def mk_relation(tstamp, parent, child, label):
    """
    Given a document and two light edus, create a relation
    instance betweenthem

    """
    span = RelSpan(parent.local_id(),
                   child.local_id())
    label = label
    annotator = 'stacparser'
    date = tstamp.next()
    rel_id = stac_glozz.anno_id_from_tuple((annotator, date))
    features = {}
    metadata = {}
    metadata['author'] = annotator
    metadata['creation-date'] = str(date)
    return Relation(rel_id=rel_id,
                    span=span,
                    rtype=label,
                    features=features,
                    metadata=metadata)

# ----------------------------------------------------------------------
# options
# ----------------------------------------------------------------------


def config_argparser(psr):
    '''
    augment argparser with flags for this utility
    '''
    psr.add_argument('input', metavar='DIR',
                     help='Glozz files (flat structure)')
    psr.add_argument('parse', metavar='FILE',
                     type=argparse.FileType('rb'),
                     help='Attelo output (.csv file)')
    psr.add_argument('output', metavar='DIR',
                     help='Output directory')

# ---------------------------------------------------------------------
# main
# ---------------------------------------------------------------------


def main():
    'main loop'

    psr = argparse.ArgumentParser(description='Display features '
                                  'related to relations.')
    config_argparser(psr)
    args = psr.parse_args()

    reader = educe.stac.LiveInputReader(args.input)
    anno_files = reader.files()
    corpus = reader.slurp(anno_files, verbose=True)

    background = pout.Background(contexts=Context.for_corpus(corpus),
                                 dialogues=pout.dialogue_map(corpus),
                                 resources={})

    tstamp = stac_glozz.PseudoTimestamper()

    # build dictionary from FileId to relations in that document
    for row in pout.read_conll(args.parse):
        lchild = pout.extract_edu(background, row)
        doc = lchild.doc.origin
        for parent, label in lchild.parents:
            rel = mk_relation(tstamp, parent, lchild.anno, label)
            lchild.doc.relations.append(rel)

    if not os.path.exists(args.output):
        os.makedirs(args.output)

    for key in corpus:
        doc = corpus[key]
        basename = os.path.join(args.output, key.doc)
        educe.glozz.write_annotation_file(basename + '.aa', doc)
        shutil.copyfile(anno_files[key][1], basename + '.ac')

if __name__ == '__main__':
    main()
