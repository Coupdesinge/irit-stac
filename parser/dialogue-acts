#!/usr/bin/env python
# pylint: disable=invalid-name
# this is a script, not a module
# pylint: enable=invalid-name

"""
Learn and predict dialogue acts from EDU feature vectors
"""

from collections import namedtuple
import argparse
import copy
import cPickle
import os

from Orange.classification import Classifier
import Orange
import Orange.data
import Orange.data.io
import Orange.feature

import educe.stac.learning.features as stac_features
import educe.stac
from educe.stac.util.output import save_document

LEARNER = Orange.classification.bayes.NaiveLearner(adjust_threshold=True)

# ---------------------------------------------------------------------
#
# ---------------------------------------------------------------------


def load_model(filename):
    """
    Load model into memory from file
    """
    with open(filename, "rb") as fstream:
        return cPickle.load(fstream)


def save_model(filename, model):
    """
    Dump model into a file
    """
    dirname = os.path.dirname(filename)
    if not os.path.exists(dirname):
        os.makedirs(dirname)
    with open(filename, "wb") as fstream:
        cPickle.dump(model, fstream)

# ---------------------------------------------------------------------
# arguments and main
# ---------------------------------------------------------------------

Features = namedtuple('Features', 'grouping label source')


def args_to_data(args):
    """
    Given the (parsed) command line arguments, return the data in
    table form
    """
    return Orange.data.Table(args.data)


def predict_dialogue_act(model, vector):
    """
    Predict the dialogue act associated with a given feature vector
    """
    return model(vector, Classifier.GetValue)


def command_save_models(args):
    """
    Top-level command: build a model using all the input data and
    dump it to disk
    """
    data = args_to_data(args)
    model = LEARNER(data)
    model_file = os.path.join(args.output, "dialogue-acts.model")
    save_model(model_file, model)


def mk_instance(domain, vec):
    """
    Build an Orange instance from an extracted feature vector
    """

    def get_val(feat):
        "get the value associated with a (meta) feature"
        val_ = vec[feat.name]
        val = val_.encode('utf-8') if isinstance(val_, unicode) else val_
        if isinstance(feat, Orange.feature.Continuous):
            return val
        elif isinstance(feat, Orange.feature.Discrete):
            if str(val) in feat.values:
                return str(val)
            else:
                return '?'
        else:
            return val

    inst = Orange.data.Instance(domain, map(get_val, domain))
    for meta in domain.get_metas().values():
        inst[meta] = str(get_val(meta))

    return inst


def model_domain(model):
    """
    Return a slightly modified version of the domain for the
    given model, partly to work around faulty type detection
    for some of the fields.
    """
    # no class variable - we don't know it yet
    domain = Orange.data.Domain(model.domain.features, False)
    for i, meta in model.domain.get_metas().items():
        # coerce meta type to string because for some odd reason
        # Orange seems to learn the dialogues as discrete
        str_meta = Orange.feature.String(meta.name)
        domain.add_meta(i, str_meta)
    return domain


def _read_annotate_inputs(args):
    """
    Return a `FeaturesInput` and a model
    """
    args.experimental = True  # use parser, not sure if we want this
    args.ignore_cdus = False
    args.debug = False
    inputs = stac_features.read_corpus_inputs(args, 'unannotated')
    model = load_model(args.model)
    return inputs, model


def _output_key(key):
    """
    Given a `FileId` key for an input document, return a version that
    would be appropriate for its output equivalent
    """
    key2 = copy.copy(key)
    key2.stage = 'units'
    key2.annotator = 'simple-da'
    return key2


def command_annotate(args):
    """
    Top-level command: given a dialogue act model, and a corpus with some
    Glozz documents, perform dialogue act annotation on them and dump Glozz
    documents in the output directory
    """
    inputs, model = _read_annotate_inputs(args)
    domain = model_domain(model)

    people = stac_features.get_players(inputs)

    # make predictions and save the output
    for k in inputs.corpus:
        doc = inputs.corpus[k]
        current = stac_features.mk_env(inputs, people, k, True).current
        edus = [unit for unit in doc.units if educe.stac.is_edu(unit)]
        for edu in edus:
            vec = stac_features.SingleEduKeysForSingleExtraction(inputs)
            vec.fill(current, edu)
            instance = mk_instance(domain, vec)
            edu.type = str(predict_dialogue_act(model, instance))
        save_document(args.output, _output_key(k), doc)


def main():
    "channel to subcommands"

    usage = "%(prog)s [options] data_file"
    parser = argparse.ArgumentParser(usage=usage)
    subparsers = parser.add_subparsers()

    common_args = argparse.ArgumentParser(add_help=False)
    common_args.add_argument("--output", "-o", metavar="DIR",
                             default=None,
                             required=True,
                             help="output directory")

    # learn command
    cmd_learn = subparsers.add_parser('learn',
                                      parents=[common_args])
    cmd_learn.add_argument("data", metavar="FILE",
                           help="csv file, one EDU per row")
    cmd_learn.set_defaults(func=command_save_models)

    # annotate command
    cmd_anno = subparsers.add_parser('annotate', parents=[common_args])
    cmd_anno.add_argument("corpus", default=None, metavar="DIR",
                          help="corpus to annotate (live mode assumed)")
    cmd_anno.add_argument('resources', metavar='DIR',
                          help='Resource dir (eg. data/resources/lexicon)')
    cmd_anno.add_argument("--model", default=None, required=True,
                          help="provide saved model for prediction of "
                          "dialogue acts")
    cmd_anno.set_defaults(func=command_annotate)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()

# vim:filetype=python:
